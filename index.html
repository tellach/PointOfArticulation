<html>

<head>
    <meta charset="utf-8" />
    <title>Points d'articulation</title>
    <link href="styles.css" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis-network.min.css" rel="stylesheet" type="text/css" />
</head>

<body onload="draw();">
    <div id="network-popUp">
        <span id="operation">node</span>
        <br>
        <table style="margin:auto;">
            <tr>
                <td>id</td>
                <td>
                    <input id="node-id" value="new value" />
                </td>
            </tr>
            <tr>
                <td>label</td>
                <td>
                    <input id="node-label" value="new value" />
                </td>
            </tr>
        </table>
        <input type="button" value="save" id="saveButton" />
        <input type="button" value="cancel" id="cancelButton" />
    </div>
    <br />
    <button id="articulation">Articulation</button>
    <div id="mynetwork"></div>
    <div id="config"></div>

</body>

</html>
<script>
        var network = null;
        var nodes = new vis.DataSet([{
                id: 0,
                label: 'Node 0'
            },
            {
                id: 1,
                label: 'Node 1'
            },
            {
                id: 2,
                label: 'Node 2'
            },
            {
                id: 3,
                label: 'Node 3'
            },
            {
                id: 4,
                label: 'Node 4'
            }
        ]);

        var edges = new vis.DataSet([{
                from: 0,
                to: 2
            },
            {
                from: 0,
                to: 1
            },
            {
                from: 1,
                to: 3
            },
            {
                from: 1,
                to: 4
            },
            {
                from: 2,
                to: 3
            }
        ]);

        // create a network
        var data = {
            nodes: nodes,
            edges: edges
        };


        function destroy() {
            if (network !== null) {
                network.destroy();
                network = null;
            }
        }

        function draw() {
            destroy();
            nodes = [];
            edges = [];

            // create a network
            var container = document.getElementById('mynetwork');
            var options = {
                manipulation: {
                    addNode: function (data, callback) {
                        // filling in the popup DOM elements
                        document.getElementById('operation').innerHTML = "Add Node";
                        document.getElementById('node-id').value = data.id;
                        document.getElementById('node-label').value = data.label;
                        document.getElementById('saveButton').onclick = saveData.bind(this, data, callback);
                        document.getElementById('cancelButton').onclick = clearPopUp.bind();
                        document.getElementById('network-popUp').style.display = 'block';
                    },
                    editNode: function (data, callback) {
                        // filling in the popup DOM elements
                        document.getElementById('operation').innerHTML = "Edit Node";
                        document.getElementById('node-id').value = data.id;
                        document.getElementById('node-label').value = data.label;
                        document.getElementById('saveButton').onclick = saveData.bind(this, data, callback);
                        document.getElementById('cancelButton').onclick = cancelEdit.bind(this, callback);
                        document.getElementById('network-popUp').style.display = 'block';
                    },
                    addEdge: function (data, callback) {
                        if (data.from == data.to) {
                            var r = confirm("Do you want to connect the node to itself?");
                            if (r == true) {
                                callback(data);
                            }
                        } else {
                            callback(data);
                        }
                    }
                },
                configure: {
                    filter: function (option, path) {
                        if (path.indexOf('physics') !== -1) {
                            return true;
                        }
                        if (path.indexOf('smooth') !== -1 || option === 'smooth') {
                            return true;
                        }
                        return false;
                    },
                    container: document.getElementById('config')
                }

            };
            network = new vis.Network(container, data, options);
        }

        function clearPopUp() {
            document.getElementById('saveButton').onclick = null;
            document.getElementById('cancelButton').onclick = null;
            document.getElementById('network-popUp').style.display = 'none';
        }

        function cancelEdit(callback) {
            clearPopUp();
            callback(null);
        }

        function saveData(data, callback) {
            data.id = document.getElementById('node-id').value;
            data.label = document.getElementById('node-label').value;
            clearPopUp();
            callback(data);
        }

        document.getElementById("articulation").addEventListener("click", tarjan);

        class Graph{
            constructor(vertices){
                this.time=0;
                this.v=vertices;
                this.adj = new Array(this.v).fill(null).map(()=>[]);
            }
            addEdge(v,w){
                this.adj[v].push(w)
                this.adj[w].push(v)
            }
            APUtil(u,visited,disc, low, parent, ap){
                var children = 0;
                visited[u] = true;
                
                disc[u] =this.time;
                low[u]  =this.time;
                this.time += 1;
               // disc[u] = low[u] = ++this.time; 
                
                var tab=this.adj[u]
                for(var i=0 ; i<tab.length ; i++){
                    var v=tab[i];
                    if (!visited[v]) {
                        children++;
                        parent[v] = u;
                        this.APUtil(v, visited, disc, low, parent, ap);


                        low[u] = Math.min(low[u],low[v]);
                        

                        if((parent[u]==0) && (children>1)){
                            ap[u] = true;
                        }



                        if ((parent[u] != 0) && (low[v] >= disc[u]) ){
                            ap[u] = true;
                        }


                        
                    }
                    else if (v != parent[u]){
                        low[u] = Math.min(low[u], disc[v]);

                    }
                }
            }
            AP(){

                let visited = Array(this.v).fill(null).map(()=>false)
                let disc = Array(this.v).fill(null).map(()=>0)
                let low = Array(this.v).fill(null).map(()=>0)
                let parent = Array(this.v).fill(null).map(()=>0)
                let ap = Array(this.v).fill(null).map(()=>false)

                for (var i=0; i<this.v; i++ ){
                    if(visited[i]==false)
                        this.APUtil(i,visited,disc,low,parent,ap);
                }


                for(var j=0 ; j<this.v ; j++){
                    data.nodes.update({ id: j, color: { background: '#349feb' } })

                    if(ap[j] == true){
                        console.log(j)
                        data.nodes.update({id:j, color : { background: '#eb4034' }})
                    }

                }
                

            }
        }

        function tarjan(){
            var edges = data.edges;
            var nodes = data.nodes;
            
            let i = 0;
            nodes.forEach(function(node,index){
                console.log(nodes.index)
                edges.forEach(edge=>{
                    if(edge.to == index) edge.to = i;
                    if(edge.from == index) edge.from = i;
                })
                
                i++;
            });

            console.log("Articulation points in first graph")
            g1=new Graph(nodes.length)
            edges.forEach(element => {
                g1.addEdge(element.from,element.to)
                
            })
            console.log(g1.adj);
            g1.AP()                                    
        }
</script>